-- Gui to Lua
-- Version: 3.2

-- Instances:

local DA = Instance.new("Part",workspace)
local DB = Instance.new("Part",workspace)

DA.BrickColor = BrickColor.new("New Yeller")
DB.BrickColor = BrickColor.new("Really red")
DA.Material = "ForceField"
DB.Material = "ForceField"
DA.Transparency = .5
DB.Transparency = .5
DA.Anchored = true
DB.Anchored = true
DA.Position = Vector3.new(0,0,0)
DB.Position = Vector3.new(0,0,0)
DA.Name = "DoorwayA"
DB.Name = "DoorwayB"
DA.Size = Vector3.new(8, 11, 1)
DB.Size = Vector3.new(8, 11, 1)
DA.CanCollide = false
DB.CanCollide = false

local Loader = Instance.new("ScreenGui")
local Mainscreen = Instance.new("Frame")
local LoadingScreen = Instance.new("Frame")
local UICorner = Instance.new("UICorner")
local Load = Instance.new("TextButton")
local UIGradient = Instance.new("UIGradient")
local Output = Instance.new("Frame")
local UIGradient_2 = Instance.new("UIGradient")
local UICorner_2 = Instance.new("UICorner")
local Code = Instance.new("TextButton")
local Controls = Instance.new("Frame")
local UICorner_3 = Instance.new("UICorner")
local Controls_2 = Instance.new("TextLabel")
local UIGradient_3 = Instance.new("UIGradient")
local button = Instance.new("TextButton")
local MainControls = Instance.new("Frame")
local UIGradient_4 = Instance.new("UIGradient")
local UICorner_4 = Instance.new("UICorner")
local One = Instance.new("TextLabel")
local UICorner_5 = Instance.new("UICorner")
local Two = Instance.new("TextLabel")
local UICorner_6 = Instance.new("UICorner")
local Three = Instance.new("TextLabel")
local UICorner_7 = Instance.new("UICorner")
local Folder_1 = Instance.new("Folder")
Folder_1.Name = "World"
Folder_1.Parent = workspace

--Properties:

Loader.Name = "Loader"
Loader.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
Loader.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

Mainscreen.Name = "Mainscreen"
Mainscreen.Parent = Loader
Mainscreen.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Mainscreen.BackgroundTransparency = 1.000
Mainscreen.Size = UDim2.new(1, 0, 1, 0)

LoadingScreen.Name = "LoadingScreen"
LoadingScreen.Parent = Mainscreen
LoadingScreen.AnchorPoint = Vector2.new(0.5, 0.899999976)
LoadingScreen.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
LoadingScreen.BackgroundTransparency = 0.500
LoadingScreen.Position = UDim2.new(0.5, 0, 0.899999976, 0)
LoadingScreen.Size = UDim2.new(0, 400, 0, 50)

UICorner.CornerRadius = UDim.new(0, 23532534)
UICorner.Parent = LoadingScreen

Load.Name = "Load"
Load.Parent = LoadingScreen
Load.AnchorPoint = Vector2.new(0.5, 0.5)
Load.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Load.BackgroundTransparency = 1.000
Load.Position = UDim2.new(0.5, 0, 0.5, 0)
Load.Size = UDim2.new(0, 400, 0, 50)
Load.Font = Enum.Font.ArialBold
Load.Text = "Start Loader"
Load.TextColor3 = Color3.fromRGB(0, 0, 0)
Load.TextSize = 30.000

UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 0, 0)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 255, 0))}
UIGradient.Rotation = 90
UIGradient.Parent = LoadingScreen

Output.Name = "Output"
Output.Parent = Mainscreen
Output.AnchorPoint = Vector2.new(1, 1)
Output.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Output.BackgroundTransparency = 0.500
Output.Position = UDim2.new(1, 0, 1, 0)
Output.Size = UDim2.new(0, 200, 0, 20)
Output.Visible = false

UIGradient_2.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 0, 0)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(20, 61, 0))}
UIGradient_2.Rotation = 90
UIGradient_2.Parent = Output

UICorner_2.CornerRadius = UDim.new(0, 23532534)
UICorner_2.Parent = Output

Code.Name = "Code"
Code.Parent = Output
Code.AnchorPoint = Vector2.new(0.5, 0.5)
Code.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Code.BackgroundTransparency = 1.000
Code.Position = UDim2.new(0.5, 0, 0.5, 0)
Code.Size = UDim2.new(0, 200, 0, 20)
Code.Font = Enum.Font.Code
Code.Text = "Warn(\"Console\")"
Code.TextColor3 = Color3.fromRGB(85, 255, 0)
Code.TextSize = 15.000
Code.TextWrapped = true

Controls.Name = "Controls"
Controls.Parent = Mainscreen
Controls.AnchorPoint = Vector2.new(1, 0.5)
Controls.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Controls.BackgroundTransparency = 0.700
Controls.Position = UDim2.new(1, 0, 0.5, 0)
Controls.Size = UDim2.new(0, 40, 0, 400)
Controls.Visible = false

UICorner_3.CornerRadius = UDim.new(0, 23532534)
UICorner_3.Parent = Controls

Controls_2.Name = "Controls"
Controls_2.Parent = Controls
Controls_2.AnchorPoint = Vector2.new(0.569999993, 0.5)
Controls_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Controls_2.BackgroundTransparency = 1.000
Controls_2.Position = UDim2.new(0.5, 0, 0.5, 0)
Controls_2.Rotation = 90.000
Controls_2.Size = UDim2.new(0, 400, 0, 40)
Controls_2.Font = Enum.Font.ArialBold
Controls_2.Text = "Controls"
Controls_2.TextColor3 = Color3.fromRGB(0, 0, 0)
Controls_2.TextSize = 35.000
Controls_2.TextWrapped = true

UIGradient_3.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 0, 0)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 255, 0))}
UIGradient_3.Rotation = 90
UIGradient_3.Parent = Controls

button.Name = "button"
button.Parent = Controls
button.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundTransparency = 1.000
button.Size = UDim2.new(0, 36, 0, 400)
button.ZIndex = 10
button.Font = Enum.Font.SourceSans
button.TextColor3 = Color3.fromRGB(0, 0, 0)
button.TextSize = 14.000
button.TextTransparency = 1.000

MainControls.Name = "MainControls"
MainControls.Parent = Mainscreen
MainControls.AnchorPoint = Vector2.new(0.5, 0.5)
MainControls.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
MainControls.Position = UDim2.new(0.5, 0, 0.5, 0)
MainControls.Size = UDim2.new(0, 500, 0, 400)
MainControls.Visible = false

UIGradient_4.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 0, 0)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 255, 0))}
UIGradient_4.Rotation = 90
UIGradient_4.Parent = MainControls

UICorner_4.CornerRadius = UDim.new(0, 40)
UICorner_4.Parent = MainControls

One.Name = "One"
One.Parent = MainControls
One.AnchorPoint = Vector2.new(0.100000001, 0.100000001)
One.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
One.BackgroundTransparency = 1.000
One.BorderColor3 = Color3.fromRGB(27, 42, 53)
One.Position = UDim2.new(0.100000001, 0, 0.100000001, 0)
One.Size = UDim2.new(0, 300, 0, 50)
One.Font = Enum.Font.ArialBold
One.Text = "Tab : Portal controls Toggle"
One.TextColor3 = Color3.fromRGB(0, 0, 0)
One.TextScaled = true
One.TextSize = 35.000
One.TextWrapped = true

UICorner_5.CornerRadius = UDim.new(0, 40)
UICorner_5.Parent = One

Two.Name = "Two"
Two.Parent = MainControls
Two.AnchorPoint = Vector2.new(0.100000001, 0.300000012)
Two.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Two.BackgroundTransparency = 1.000
Two.BorderColor3 = Color3.fromRGB(27, 42, 53)
Two.Position = UDim2.new(0.100000001, 0, 0.300000012, 0)
Two.Size = UDim2.new(0, 300, 0, 50)
Two.Font = Enum.Font.ArialBold
Two.Text = "LMB : Create Red Portal"
Two.TextColor3 = Color3.fromRGB(0, 0, 0)
Two.TextScaled = true
Two.TextSize = 35.000
Two.TextWrapped = true

UICorner_6.CornerRadius = UDim.new(0, 40)
UICorner_6.Parent = Two

Three.Name = "Three"
Three.Parent = MainControls
Three.Active = true
Three.AnchorPoint = Vector2.new(0.100000001, 0.5)
Three.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Three.BackgroundTransparency = 1.000
Three.BorderColor3 = Color3.fromRGB(27, 42, 53)
Three.Position = UDim2.new(0.100000001, 0, 0.5, 0)
Three.Size = UDim2.new(0, 300, 0, 50)
Three.Font = Enum.Font.ArialBold
Three.Text = "RMB : Create Yellow Portal"
Three.TextColor3 = Color3.fromRGB(0, 0, 0)
Three.TextScaled = true
Three.TextSize = 35.000
Three.TextWrapped = true

UICorner_7.CornerRadius = UDim.new(0, 40)
UICorner_7.Parent = Three

-- Module Scripts:

local fake_module_scripts = {}

do -- Mainscreen.DualWorlds
	local script = Instance.new('ModuleScript', Mainscreen)
	script.Name = "DualWorlds"
	local function module_script()
		local Y_SPIN = CFrame.Angles(0, math.pi, 0)
		
		local PortalClass = require(script:WaitForChild("Portal"))
		
		--
		
		local function planeIntersect(point, vector, origin, normal)
			local rpoint = point - origin;
			local t = -rpoint:Dot(normal)/vector:Dot(normal);
			return point + t * vector, t;
		end
		
		
		local function rayPlane(p, v, o, n)
			local r = p - o
			local t = -r:Dot(n) / v:Dot(n)
			return p + t*v, t
		end
		
		-- Class
		
		local DualWorlds = {}
		DualWorlds.__index = DualWorlds
		
		function DualWorlds.new(character, partA, partB, surface, parent)
			local self = setmetatable({}, DualWorlds)
			
			self.Character = character
			self.HRP = character:WaitForChild("HumanoidRootPart")
			self.Humanoid = character:WaitForChild("Humanoid")
			
			self.PortalA = PortalClass.fromPart(partA, surface, parent)
			self.PortalB = PortalClass.fromPart(partB, surface, parent)
			
			self.LastCamCF = game.Workspace.CurrentCamera.CFrame
		
			game:GetService("RunService"):BindToRenderStep("BeforeInput", Enum.RenderPriority.Input.Value - 1, function(dt)
				game.Workspace.CurrentCamera.CFrame = self.LastCamCF
			end)
			
			game:GetService("RunService"):BindToRenderStep("AfterCamera", Enum.RenderPriority.Camera.Value + 1, function(dt)
				self:OnRenderStep(dt)
			end)
		
			return self
		end
		
		-- Public Methods
		
		function DualWorlds:CheckCameraIntersect(surface, size)
			local camCF = game.Workspace.CurrentCamera.CFrame
			local focusCF = game.Workspace.CurrentCamera.Focus
			
			local v = camCF.p - focusCF.p
			local p, t = rayPlane(focusCF.p, camCF.p - focusCF.p, surface.p, surface.LookVector)
			if (v:Dot(surface.LookVector) < 0 and t >= 0 and t <= 1) then
				local lp = surface:PointToObjectSpace(p)
				if (math.abs(lp.x) <= size.x/2 and math.abs(lp.y) <= size.y/2) then
					return true
				end
			end
			
			return false
		end
		
		function DualWorlds:CameraIntersectOffset(surfaceA, surfaceB)
			local camCF = game.Workspace.CurrentCamera.CFrame
			local focusCF = game.Workspace.CurrentCamera.Focus
			
			local offset = surfaceA:Inverse() * camCF
			local newCam = surfaceB * Y_SPIN * offset
			
			local offset = surfaceA:Inverse() * focusCF
			local newFocus = surfaceB * Y_SPIN * offset
			
			game.Workspace.CurrentCamera.CFrame = newCam
			game.Workspace.CurrentCamera.Focus = newFocus
		end
		
		function DualWorlds:InfrontOf(pos, surface, size)
			local lp = (surface - surface.p + pos):PointToObjectSpace(self.HRP.Position)
			if (lp.z <= 0 and math.abs(lp.x) <= size.x/2 and math.abs(lp.y) <= size.y/2) then
				return true
			end
			return false
		end
		
		function DualWorlds:CheckCollision(surface, size, dt)
			local p, t = rayPlane(self.HRP.Position, self.HRP.Velocity*dt, surface.p, surface.LookVector)
			local lp = surface:PointToObjectSpace(p)
			if (t >= 0 and t <= 1 and math.abs(lp.x) <= size.x/2 and math.abs(lp.y) <= size.y/2) then
				return true
			end
			return false
		end
		
		function DualWorlds:MoveToPortal(surfaceA, surfaceB)
			local hrpCF = self.HRP.CFrame
			local camCF = game.Workspace.CurrentCamera.CFrame
			local velocity = self.HRP.Velocity
			local moveDir = self.Humanoid.MoveDirection
			
			local hrpOffset = surfaceA:Inverse() * hrpCF
			local c = {hrpOffset:GetComponents()}
			local alteredOffset = CFrame.new(-c[1], select(2, unpack(c)))
			local newHrp = surfaceB * alteredOffset * Y_SPIN
			
			local lVel = hrpCF:VectorToObjectSpace(velocity)
			local newVel = newHrp:VectorToWorldSpace(lVel)
			
			local lMove = hrpCF:VectorToObjectSpace(moveDir)
			local newMove = newHrp:VectorToWorldSpace(lMove)
			
			local camOffset = surfaceA:Inverse() * camCF
			local newCam = surfaceB * Y_SPIN * camOffset
			
			self.HRP.CFrame = newHrp
			self.HRP.Velocity = newVel
			self.Humanoid:Move(newMove, false)
			return newCam
		end
		
		function DualWorlds:OnRenderStep(dt)
			local portalA, portalB = self.PortalA, self.PortalB
			local surfaceA, sizeA = portalA:GetSurfaceInfo()
			local surfaceB, sizeB = portalB:GetSurfaceInfo()
			
			-- collision check
			
			self.LastCamCF = game.Workspace.CurrentCamera.CFrame
			
			if (self:CheckCollision(surfaceA, sizeA, dt)) then
				self.LastCamCF = self:MoveToPortal(surfaceA, surfaceB)
			elseif (self:CheckCollision(surfaceB, sizeB, dt)) then
				self.LastCamCF = self:MoveToPortal(surfaceB, surfaceA)
			end
			
			-- camera adjustment
			
			if (self:CheckCameraIntersect(surfaceA, sizeA)) then
				self:CameraIntersectOffset(surfaceA, surfaceB)
			elseif (self:CheckCameraIntersect(surfaceB, sizeB)) then
				self:CameraIntersectOffset(surfaceB, surfaceA)
			end
			
			-- render portal
			
			local camCF = game.Workspace.CurrentCamera.CFrame
			
			local offset = surfaceA:Inverse() * camCF
			local newCamCF = surfaceB * Y_SPIN * offset
			portalA:RenderFrame(newCamCF, surfaceB * Y_SPIN, sizeB)
			
			local offset = surfaceB:Inverse() * camCF
			local newCamCF = surfaceA * Y_SPIN * offset
			portalB:RenderFrame(newCamCF, surfaceA * Y_SPIN, sizeA)
		end
		
		--
		
		return DualWorlds
	end
	fake_module_scripts[script] = module_script
end
do -- nil.Portal
	local script = Instance.new('ModuleScript', nil)
	script.Name = "Portal"
	local function module_script()
		local UP = Vector3.new(0, 1, 0)
		local FOV120 = math.rad(120)
		local PI2 = math.pi/2
		
		local VPF = Instance.new("ViewportFrame")
		VPF.Size = UDim2.new(1, 0, 1, 0)
		VPF.Position = UDim2.new(0.5, 0, 0.5, 0)
		VPF.AnchorPoint = Vector2.new(0.5, 0.5)
		VPF.BackgroundTransparency = 1
		
		--
		
		local function getCorners(part)
			local corners = {}
			local cf, size2 = part.CFrame, part.Size/2
			for x = -1, 1, 2 do
				for y = -1, 1, 2 do
					for z = -1, 1, 2 do
						table.insert(corners, cf * (size2 * Vector3.new(x, y, z)))
					end
				end
			end
			return corners
		end
		
		--
		
		local Portal = {}
		Portal.__index = Portal
		
		--
		
		function Portal.new(surfaceGUI)
			local self = setmetatable({}, Portal)
			
			self.SurfaceGUI = surfaceGUI
			self.Camera = Instance.new("Camera", surfaceGUI)
			self.ViewportFrame = VPF:Clone()
			self.ViewportFrame.CurrentCamera = self.Camera
			self.ViewportFrame.Parent = surfaceGUI
			
			return self
		end
		
		function Portal.fromPart(part, enum, parent)
			local surfaceGUI = Instance.new("SurfaceGui")
			surfaceGUI.Face = enum
			surfaceGUI.Adornee = part
			surfaceGUI.ClipsDescendants = true
			surfaceGUI.Parent = parent
			
			return Portal.new(surfaceGUI)
		end
		
		--
		
		function Portal:AddToWorld(item)
			item.Parent = self.ViewportFrame
		end
		
		function Portal:ClipModel(model)
			local cf, size = self:GetSurfaceInfo()
			local descendants = model:GetDescendants()
			for i = 1, #descendants do
				local part = descendants[i]
				if (part:IsA("BasePart")) then
					local corners = getCorners(part)
					table.insert(corners, 1, part.Position)
					
					local pass = false
					for j = 1, #corners do
						if (cf:PointToObjectSpace(corners[j]).z <= 0) then
							pass = true
							break
						end
					end
					
					if (not pass) then
						part:Destroy()
					end
				end
			end
			return model
		end
		
		function Portal:GetPart()
			return self.SurfaceGUI.Adornee
		end
		
		function Portal:GetSurfaceInfo()
			local part = self.SurfaceGUI.Adornee
			local partCF, partSize = part.CFrame, part.Size
			
			local back = -Vector3.FromNormalId(self.SurfaceGUI.Face)
			local axis = (math.abs(back.y) == 1) and Vector3.new(back.y, 0, 0) or UP
			local right = CFrame.fromAxisAngle(axis, PI2) * back
			local top = back:Cross(right).Unit
			
			local cf = partCF * CFrame.fromMatrix(-back*partSize/2, right, top, back)
			local size = Vector3.new((partSize * right).Magnitude, (partSize * top).Magnitude, (partSize * back).Magnitude)
		
			return cf, size
		end
		
		function Portal:RenderFrame(camCF, surfaceCF, surfaceSize)
			local vpf = self.ViewportFrame
			local surfaceGUI = self.SurfaceGUI
			local camera = game.Workspace.CurrentCamera
			local nCamera = self.Camera
			
			local camCF = camCF or camera.CFrame
			if not (surfaceCF and surfaceSize) then 
				surfaceCF, surfaceSize = self:GetSurfaceInfo()
			end
			
			local rPoint = surfaceCF:PointToObjectSpace(camCF.p)
			local sX, sY = rPoint.x / surfaceSize.x, rPoint.y / surfaceSize.y
			
			local scale = 1 + math.max(
				surfaceSize.y / surfaceSize.x, 
				surfaceSize.x / surfaceSize.y, 
				math.max(math.abs(sX), math.abs(sY))*2
			)
			
			local height = surfaceSize.y/2
			local rDist = (camCF.p - surfaceCF.p):Dot(surfaceCF.LookVector)
			local newFov = 2*math.atan2(height, rDist)
			local clampedFov = math.clamp(math.deg(newFov), 1, 120)
			local pDist = height / math.tan(math.rad(clampedFov)/2)
			local adjust = rDist / pDist
			
			local factor = (newFov > FOV120 and adjust or 1) / scale
			local scaleCF = CFrame.new(0, 0, 0, factor, 0, 0, 0, factor, 0, 0, 0, 1)
			
			vpf.Position = UDim2.new(vpf.AnchorPoint.x - sX, 0, vpf.AnchorPoint.y - sY, 0)
			vpf.Size = UDim2.new(scale, 0, scale, 0)
			vpf.BackgroundColor3 = surfaceGUI.Adornee.Color
			
			local viewportSizeY = camera.ViewportSize.y
			surfaceGUI.CanvasSize = Vector2.new(viewportSizeY*(surfaceSize.x/surfaceSize.y), viewportSizeY)
			
			nCamera.FieldOfView = clampedFov
			nCamera.CFrame = CFrame.new(camCF.p) * (surfaceCF - surfaceCF.p) * CFrame.Angles(0, math.pi, 0) * scaleCF
		end
		
		--
		
		return Portal
	end
	fake_module_scripts[script] = module_script
end
do -- Mainscreen.CharacterClone
	local script = Instance.new('ModuleScript', Mainscreen)
	script.Name = "CharacterClone"
	local function module_script()
		local CharacterClone = {}
		CharacterClone.__index = CharacterClone
		
		--
		
		function CharacterClone.new(character)
			local self = setmetatable({}, CharacterClone)
			
			self.Character = character
			self.Clone = character:Clone()
		
			self.Clone:WaitForChild("Humanoid").DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
			self.Lookup = self:GetLookup()
			
			return self
		end
		
		--
		
		function CharacterClone:GetLookup()
			local lookup = {}
			local character = self.Character
			for _, item in next, self.Clone:GetChildren() do
				if (item:IsA("BasePart")) then
					item.Anchored = true
					local match = character:FindFirstChild(item.Name)
					lookup[item] = match
				elseif (item:IsA("Accessory")) then
					local match = character:FindFirstChild(item.Name).Handle
					item = item.Handle
					item.Anchored = true
					lookup[item] = match
				elseif (item:IsA("LuaSourceContainer")) then
					item:Destroy()
				end
			end
			return lookup
		end
		
		function CharacterClone:Update()
			for fake, real in next, self.Lookup do
				fake.CFrame = real.CFrame
			end
		end
		
		--
		
		return CharacterClone
	end
	fake_module_scripts[script] = module_script
end


-- Scripts:

local function FXLVRC_fake_script() -- Mainscreen.MainScript 
	local script = Instance.new('LocalScript', Mainscreen)
	local req = require
	local require = function(obj)
		local fake = fake_module_scripts[obj]
		if fake then
			return fake()
		end
		return req(obj)
	end

	script.Parent.LoadingScreen.Load.MouseButton1Click:Connect(function()
		script.Parent.Output.Visible = true
		for _,v in pairs(script.Parent.Parent:GetDescendants()) do
			script.Parent.Output.Code.Text = ("Loading "..v.Name)
			wait(math.random(0,.1))
		end
		script.Parent.Controls.Visible = true
		script.Parent.LoadingScreen.Visible = false
	end)
	
	local tog = false
	
	script.Parent.Controls.button.MouseButton1Click:Connect(function()
		if tog == false then
			script.Parent.MainControls.Visible = true
			tog = true
		else
			tog = false
			script.Parent.MainControls.Visible = false
		end
	end)
	
	
	

	

end

coroutine.wrap(FXLVRC_fake_script)()
local function EQRD_fake_script() -- Mainscreen.FixedBlock 
	local script = Instance.new('LocalScript', Mainscreen)
	local req = require
	local require = function(obj)
		local fake = fake_module_scripts[obj]
		if fake then
			return fake()
		end
		return req(obj)
	end

	local localPlayer = game.Players.LocalPlayer
	
	local doorA = game.Workspace.DoorwayA
	local doorB = game.Workspace.DoorwayB
	local world = game.Workspace.World
	
	--
	
	local dualWorld = require(game.ReplicatedStorage.DualWorlds).new(localPlayer.Character, doorA, doorB, Enum.NormalId.Front, localPlayer.PlayerGui)
	
	dualWorld.PortalA:AddToWorld(dualWorld.PortalB:ClipModel(world:Clone()))
	dualWorld.PortalB:AddToWorld(dualWorld.PortalA:ClipModel(world:Clone()))
	
	--
	
	local characterClone = require(game.ReplicatedStorage.CharacterClone)
	local clones = {}
	
	local function onCharacter(character)
		if (character) then
			character.Archivable = true
			character:WaitForChild("Humanoid") -- weird bug
			
			local cloneA = characterClone.new(character)
			local cloneB = characterClone.new(character)
			dualWorld.PortalA:AddToWorld(cloneA.Clone)
			dualWorld.PortalB:AddToWorld(cloneB.Clone)
			table.insert(clones, cloneA)
			table.insert(clones, cloneB)
		end
	end
	
	game.Players.PlayerAdded:Connect(function(player)
		player.CharacterAdded:Connect(onCharacter)
	end)
	
	wait(1)
	
	for _, player in next, game.Players:GetPlayers() do
		onCharacter(player.Character)
		player.CharacterAdded:Connect(onCharacter)
	end
	
	game:GetService("RunService").RenderStepped:Connect(function(dt)
		for i = 1, #clones do
			clones[i]:Update()
		end
	end)
end

script.Parent.FixedBlock.Parent = workspace
script.Parent.CharacterClone.Parent = game.ReplicatedStorage
script.Parent.DualWorlds.Parent = game.ReplicatedStorage

coroutine.wrap(EQRD_fake_script)()


-- fixedblock goes to SCS

-- characterclone and duelworlds RS

